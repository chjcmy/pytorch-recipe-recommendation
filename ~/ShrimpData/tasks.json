{
  "tasks": [
    {
      "id": "61ac729f-7fb6-4a75-83f2-fce1de3ee506",
      "name": "Phase 1.1: 프로젝트 폴더 구조 생성",
      "description": "프로젝트에 필요한 디렉토리 구조를 생성합니다.",
      "status": "completed",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T04:29:13.918Z",
      "implementationGuide": "```bash\ncd ~\nmkdir pytorch-recipe-recommendation\ncd pytorch-recipe-recommendation\nmkdir -p data models training api notebooks tests configs checkpoints\n```",
      "verificationCriteria": "`ls -la` 실행 시 모든 폴더가 보여야 합니다.",
      "summary": "프로젝트 폴더 구조 생성을 완료했습니다. 필요한 모든 디렉토리가 성공적으로 생성되었음을 확인했습니다.",
      "completedAt": "2025-10-30T04:29:13.917Z"
    },
    {
      "id": "4546184b-56ec-4bc3-9546-7bab9225f003",
      "name": "Phase 1.2: Git 초기화",
      "description": "새로운 Git 저장소를 초기화하고 .gitignore 파일을 생성합니다.",
      "status": "completed",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T04:35:44.241Z",
      "implementationGuide": "```bash\ngit init\n\ncat > .gitignore << 'EOF'\n__pycache__/\n*.py[cod]\nvenv/\ndata/*.csv\ndata/*.zip\n*.pth\ncheckpoints/\n.ipynb_checkpoints/\n.DS_Store\n.kaggle/\nEOF\n\ngit add .gitignore\ngit commit -m \"Initial commit\"\n```",
      "verificationCriteria": "`git log` 실행 시 초기 커밋이 보여야 합니다.",
      "summary": "Git 저장소를 초기화하고 .gitignore 파일을 생성 및 커밋했습니다. `git log`를 통해 초기 커밋을 확인했습니다.",
      "completedAt": "2025-10-30T04:35:44.240Z"
    },
    {
      "id": "03e6fa4f-3a6a-4da5-b74b-583d0a547222",
      "name": "Phase 1.3: Python 가상환경 생성",
      "description": "프로젝트를 위한 Python 가상환경을 설정합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T03:38:09.081Z",
      "implementationGuide": "```bash\npython3 -m venv venv\nsource venv/bin/activate\nwhich python\n```",
      "verificationCriteria": "터미널에 `(venv)`가 표시되어야 합니다."
    },
    {
      "id": "8197de54-b216-458d-a9f2-f093aca750cb",
      "name": "Phase 1.4: requirements.txt 작성 및 패키지 설치",
      "description": "필요한 Python 패키지를 정의하고 설치합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T03:38:09.081Z",
      "implementationGuide": "```bash\ncat > requirements.txt << 'EOF'\ntorch==2.1.0\ntorchvision==0.16.0\npandas==2.1.0\nnumpy==1.25.0\nscikit-learn==1.3.0\nmatplotlib==3.8.0\nseaborn==0.13.0\nfastapi==0.104.0\nuvicorn==0.24.0\npydantic==2.4.0\ntqdm==4.66.0\npyyaml==6.0.1\npython-dotenv==1.0.0\njupyter==1.0.0\nipykernel==6.25.0\nkaggle==1.5.16\nEOF\n\npip install --upgrade pip\npip install -r requirements.txt\n\npython -c \"import torch; print(f'PyTorch: {torch.__version__}')\"\npython -c \"import torch; print(f'MPS: {torch.backends.mps.is_available()}')\"\n```",
      "verificationCriteria": "\"PyTorch: 2.1.0\" 및 \"MPS: True\"가 출력되어야 합니다."
    },
    {
      "id": "5e2bfd11-31f5-4fcf-a1db-b7488403b86a",
      "name": "Phase 1.5: README.md 작성",
      "description": "프로젝트 개요, 설정 방법, 목표 등을 포함하는 README.md 파일을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T03:38:09.081Z",
      "implementationGuide": "```bash\ncat > README.md << 'EOF'\n# PyTorch Recipe Recommendation System\n\nNCF (Neural Collaborative Filtering) 기반 레시피 추천 시스템\n\n## 📌 프로젝트 정보\n- **시작일**: 2025-10-30\n- **목표**: Food.com 데이터로 개인화 추천 구현\n- **모델**: Neural Collaborative Filtering\n\n## 🛠️ 기술 스택\n- PyTorch 2.1.0\n- FastAPI\n- TypeScript/Next.js\n\n## 📁 프로젝트 구조\n```\npytorch-recipe-recommendation/\n├── data/               # 데이터셋\n├── models/             # NCF 모델\n├── training/           # 학습 스크립트\n├── api/               # FastAPI\n├── notebooks/         # Jupyter\n└── checkpoints/       # 학습된 모델\n```\n\n## 🚀 실행 방법\n\n### 환경 설정\n```\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n```\n\n### 데이터 다운로드\n```\nkaggle datasets download -d shuyangli94/food-com-recipes-and-user-interactions -p ./data\ncd data && unzip food-com-recipes-and-user-interactions.zip\n```\n\n### 전처리\n```\npython training/preprocess.py\n```\n\n### 학습\n```\npython training/train.py\n```\n\n### API 실행\n```\nuvicorn api.main:app --reload\n```\n\n## 📊 목표 성능\n- AUC: 0.83+\n- NDCG@10: 0.38+\n- API 응답: < 200ms\n\n## 📝 진행 상황\n- [ ] Phase 1: 프로젝트 초기 설정\n- [ ] Phase 2: 데이터 수집 및 탐색\n- [ ] Phase 3: 모델 구현\n- [ ] Phase 4: 학습 및 평가\n- [ ] Phase 5: API 구축\n- [ ] Phase 6: 배포\n\n## 📄 라이센스\nMIT\nEOF\n```",
      "verificationCriteria": "README.md 파일이 존재해야 합니다."
    },
    {
      "id": "36141c3e-ce9b-46bb-bd1a-25d284b26054",
      "name": "Phase 1.6: config.yaml 작성",
      "description": "모델, 학습, 데이터 관련 설정을 포함하는 config.yaml 파일을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T03:38:09.081Z",
      "implementationGuide": "```bash\ncat > configs/config.yaml << 'EOF'\nmodel:\n  embedding_dim: 32\n  mlp_layers: [64, 32, 16]\n  dropout: 0.2\n\ntraining:\n  batch_size: 256\n  learning_rate: 0.001\n  epochs: 10\n  weight_decay: 0.00001\n  early_stopping_patience: 3\n\ndata:\n  train_ratio: 0.7\n  val_ratio: 0.15\n  test_ratio: 0.15\n  min_rating: 4\n  sample_size: 10000\n\nrecommendation:\n  top_k: 10\n  cold_start_strategy: \"popular\"\n\napi:\n  host: \"0.0.0.0\"\n  port: 8000\n  cors_origins: \n    - \"http://localhost:3000\"\nEOF\n```",
      "verificationCriteria": "configs/config.yaml 파일이 존재해야 합니다."
    },
    {
      "id": "11012e5f-3ba5-49c8-b6c2-52546b5a1314",
      "name": "Phase 1.7: Git 커밋",
      "description": "초기 프로젝트 설정 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:09.081Z",
      "updatedAt": "2025-10-30T03:38:09.081Z",
      "implementationGuide": "```bash\ngit add .\ngit commit -m \"feat: Initial project setup\n\n- Created project structure\n- Set up virtual environment\n- Installed dependencies\n- Added README and config\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "7a545c1e-2ac5-4f8e-b91a-d8b9f394e061",
      "name": "Phase 2.1: Kaggle API 설정",
      "description": "Kaggle 데이터셋을 다운로드하기 위해 API를 설정합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:35.560Z",
      "updatedAt": "2025-10-30T03:38:35.560Z",
      "implementationGuide": "```bash\n# 1. https://www.kaggle.com 로그인\n# 2. Settings → API → Create New Token\n# 3. kaggle.json 다운로드\n\nmkdir -p ~/.kaggle\nmv ~/Downloads/kaggle.json ~/.kaggle/\nchmod 600 ~/.kaggle/kaggle.json\n\nkaggle --version\n```",
      "verificationCriteria": "`kaggle --version`이 정상적으로 실행되어야 합니다."
    },
    {
      "id": "12b0db9d-5f8b-4b4e-a34a-7d1d528e644c",
      "name": "Phase 2.2: Food.com 데이터셋 다운로드",
      "description": "Kaggle에서 Food.com 레시피 및 상호작용 데이터셋을 다운로드합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:35.560Z",
      "updatedAt": "2025-10-30T03:38:35.560Z",
      "implementationGuide": "```bash\ncd data\nkaggle datasets download -d shuyangli94/food-com-recipes-and-user-interactions\nunzip food-com-recipes-and-user-interactions.zip\nls -lh *.csv\nrm food-com-recipes-and-user-interactions.zip\ncd ..\n```",
      "verificationCriteria": "`data/RAW_recipes.csv`와 `data/RAW_interactions.csv` 파일이 존재해야 합니다."
    },
    {
      "id": "26822001-3bf8-4868-9f59-75fcce522bfa",
      "name": "Phase 2.3: 데이터 기본 확인",
      "description": "다운로드한 데이터의 기본적인 통계를 확인합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:35.560Z",
      "updatedAt": "2025-10-30T03:38:35.560Z",
      "implementationGuide": "```bash\npython << 'EOF'\nimport pandas as pd\n\nrecipes = pd.read_csv('data/RAW_recipes.csv')\ninteractions = pd.read_csv('data/RAW_interactions.csv')\n\nprint(\"=\"*80)\nprint(\"Food.com Dataset 정보\")\nprint(\"=\"*80)\nprint(f'\n레시피 수: {len(recipes):,}개')\nprint(f'상호작용 수: {len(interactions):,}개')\nprint(f'고유 사용자: {interactions['user_id'].nunique():,}명')\nprint(f'고유 레시피: {interactions['recipe_id'].nunique():,}개')\nprint(f'\n평점 분포:')\nprint(interactions['rating'].value_counts().sort_index())\nprint(\"\n✅ 데이터 로드 성공!\")\nEOF\n```",
      "verificationCriteria": "데이터 통계가 출력되어야 합니다."
    },
    {
      "id": "0723e453-860d-4704-8e5a-213947f48f56",
      "name": "Phase 2.4: EDA Jupyter Notebook 작성",
      "description": "데이터 탐색 및 시각화를 위한 Jupyter Notebook을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:35.560Z",
      "updatedAt": "2025-10-30T03:38:35.560Z",
      "implementationGuide": "```bash\njupyter notebook\n```\n\n`notebooks/01_data_exploration.ipynb` 생성:\n\n```python\n# Cell 1: 라이브러리\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\n# Cell 2: 데이터 로드\nrecipes = pd.read_csv('../data/RAW_recipes.csv')\ninteractions = pd.read_csv('../data/RAW_interactions.csv')\nprint(f\"레시피: {len(recipes):,}, 상호작용: {len(interactions):,}\")\n\n# Cell 3: 레시피 탐색\nprint(recipes.info())\nprint(recipes.describe())\nrecipes.head()\n\n# Cell 4: 조리 시간 분포\nplt.figure(figsize=(14, 5))\nplt.subplot(1, 2, 1)\nrecipes['minutes'].hist(bins=100, edgecolor='black')\nplt.xlabel('Cooking Time (minutes)')\nplt.title('Cooking Time Distribution')\nplt.xlim(0, 500)\n\nplt.subplot(1, 2, 2)\nrecipes[recipes['minutes'] <= 120]['minutes'].hist(bins=60, color='orange')\nplt.xlabel('Cooking Time (minutes)')\nplt.title('Cooking Time (<= 120 min)')\nplt.tight_layout()\nplt.show()\n\n# Cell 5: 재료 개수 분포\nplt.figure(figsize=(10, 5))\nrecipes['n_ingredients'].value_counts().sort_index().plot(kind='bar', color='green')\nplt.xlabel('Number of Ingredients')\nplt.title('Ingredient Count Distribution')\nplt.show()\n\n# Cell 6: 평점 분포\nplt.figure(figsize=(12, 5))\nplt.subplot(1, 2, 1)\ninteractions['rating'].value_counts().sort_index().plot(kind='bar')\nplt.xlabel('Rating')\nplt.title('Rating Distribution')\n\nplt.subplot(1, 2, 2)\ninteractions['rating'].value_counts().sort_index().plot(kind='pie', autopct='%1.1f%%')\nplt.title('Rating Percentage')\nplt.tight_layout()\nplt.show()\n\n# Cell 7: 사용자/레시피 활동\nuser_activity = interactions.groupby('user_id').size()\nrecipe_popularity = interactions.groupby('recipe_id').size()\n\nplt.figure(figsize=(12, 5))\nplt.subplot(1, 2, 1)\nuser_activity.hist(bins=50)\nplt.xlabel('Reviews per User')\nplt.title('User Activity')\nplt.xlim(0, 50)\n\nplt.subplot(1, 2, 2)\nrecipe_popularity.hist(bins=50, color='coral')\nplt.xlabel('Reviews per Recipe')\nplt.title('Recipe Popularity')\nplt.xlim(0, 50)\nplt.tight_layout()\nplt.show()\n\n# Cell 8: 인사이트\npositive_threshold = 4\npositive_ratio = (interactions['rating'] >= positive_threshold).mean()\n\nprint(\"=\"*80)\nprint(\"추천 시스템 설계 인사이트\")\nprint(\"=\"*80)\nprint(f\"\n1. 라벨링: {positive_threshold}점 이상 = 긍정\")\nprint(f\"   긍정 비율: {positive_ratio*100:.1f}%\")\n\ntotal_possible = interactions['user_id'].nunique() * interactions['recipe_id'].nunique()\nsparsity = 1 - (len(interactions) / total_possible)\nprint(f\"\n2. 희소성: {sparsity*100:.2f}%\")\n\nprint(f\"\n3. Cold Start:\")\nprint(f\"   리뷰 ≤5개 사용자: {(user_activity <= 5).sum():,}명\")\nprint(f\"   리뷰 ≤5개 레시피: {(recipe_popularity <= 5).sum():,}개\")\n\nprint(\"\n✅ EDA 완료!\")\n```",
      "verificationCriteria": "노트북이 실행 완료되고 모든 그래프가 생성되어야 합니다."
    },
    {
      "id": "c4658583-9bb0-467f-8ae2-b652e1b5a258",
      "name": "Phase 2.5: Git 커밋",
      "description": "EDA 노트북 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:38:35.560Z",
      "updatedAt": "2025-10-30T03:38:35.560Z",
      "implementationGuide": "```bash\ngit add notebooks/01_data_exploration.ipynb\ngit commit -m \"feat: Add EDA notebook\n\n- Analyzed recipe and interaction data\n- Visualized distributions\n- Identified sparsity and cold start issues\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "e0e5d6a0-e68e-437b-8104-5b66907e73fd",
      "name": "Phase 3.1: models 패키지 초기화",
      "description": "모델 관련 모듈을 포함할 `models` 패키지를 초기화합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:39:14.915Z",
      "updatedAt": "2025-10-30T03:39:14.915Z",
      "implementationGuide": "```bash\ncat > models/__init__.py << 'EOF'\nfrom .ncf_model import NCF\nfrom .dataset import RecipeNCFDataset\n\n__all__ = ['NCF', 'RecipeNCFDataset']\nEOF\n```",
      "verificationCriteria": "`models/__init__.py` 파일이 생성되어야 합니다."
    },
    {
      "id": "b546af58-2077-40c2-a137-f508ad535587",
      "name": "Phase 3.2: RecipeNCFDataset 클래스 작성",
      "description": "PyTorch `Dataset`을 상속받아 레시피 추천 모델을 위한 데이터셋 클래스를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:39:26.081Z",
      "updatedAt": "2025-10-30T03:39:26.081Z",
      "implementationGuide": "```bash\ncat > models/dataset.py << 'EOF'\nimport torch\nfrom torch.utils.data import Dataset\nimport pandas as pd\n\nclass RecipeNCFDataset(Dataset):\n    def __init__(self, dataframe):\n        required_cols = ['user_id', 'recipe_id', 'label']\n        for col in required_cols:\n            if col not in dataframe.columns:\n                raise ValueError(f\"Missing column: {col}\")\n        \n        self.user_ids = torch.tensor(dataframe['user_id'].values, dtype=torch.long)\n        self.recipe_ids = torch.tensor(dataframe['recipe_id'].values, dtype=torch.long)\n        self.labels = torch.tensor(dataframe['label'].values, dtype=torch.float32)\n        \n        print(f\"✅ Dataset: {len(self)} samples\")\n        print(f\"   Positive: {self.labels.mean()*100:.1f}%\")\n    \n    def __len__(self):\n        return len(self.user_ids)\n    \n    def __getitem__(self, idx):\n        return {\n            'user_id': self.user_ids[idx],\n            'recipe_id': self.recipe_ids[idx],\n            'label': self.labels[idx]\n        }\n    \n    def get_num_users(self):\n        return self.user_ids.max().item() + 1\n    \n    def get_num_recipes(self):\n        return self.recipe_ids.max().item() + 1\n\nif __name__ == \"__main__\":\n    test_df = pd.DataFrame({\n        'user_id': [1, 2, 3],\n        'recipe_id': [10, 20, 30],\n        'label': [1, 0, 1]\n    })\n    dataset = RecipeNCFDataset(test_df)\n    print(f\"Length: {len(dataset)}\")\n    print(f\"Sample: {dataset[0]}\")\n    print(\"✅ Test passed!\")\nEOF\n\npython models/dataset.py\n```",
      "verificationCriteria": "\"✅ Test passed!\"가 출력되어야 합니다."
    },
    {
      "id": "dfeeac2d-31e4-476d-8c32-42cdd48bb62d",
      "name": "Phase 3.4: Git 커밋",
      "description": "NCF 모델 및 데이터셋 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:39:58.873Z",
      "updatedAt": "2025-10-30T03:39:58.873Z",
      "implementationGuide": "```bash\ngit add models/\ngit commit -m \"feat: Add NCF model and Dataset\n\n- Implemented RecipeNCFDataset\n- Implemented NCF (GMF + MLP)\n- Added weight initialization\n- Tested on sample data\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "48394c9e-621d-41fc-8efe-06b9c3ed4f18",
      "name": "Phase 4.1: 전처리 스크립트 작성",
      "description": "데이터를 로드, 라벨링, 샘플링, 분할하고 결과를 저장하는 전처리 스크립트를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:40:14.165Z",
      "updatedAt": "2025-10-30T03:40:14.165Z",
      "implementationGuide": "```bash\ncat > training/preprocess.py << 'EOF'\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nimport yaml\nimport json\n\ndef load_config():\n    with open('configs/config.yaml') as f:\n        return yaml.safe_load(f)\n\ndef preprocess():\n    print(\"=\"*80)\n    print(\"데이터 전처리 시작\")\n    print(\"=\"*80)\n    \n    config = load_config()\n    \n    # 로드\n    print(\"\\n데이터 로딩...\")\n    recipes = pd.read_csv('data/RAW_recipes.csv')\n    interactions = pd.read_csv('data/RAW_interactions.csv')\n    print(f\"  레시피: {len(recipes):,}, 상호작용: {len(interactions):,}\")\n    \n    # 0점 제거\n    interactions = interactions[interactions['rating'] > 0].copy()\n    \n    # 라벨링\n    min_rating = config['data']['min_rating']\n    interactions['label'] = (interactions['rating'] >= min_rating).astype(np.float32)\n    print(f\"\\n라벨링 ({min_rating}점 이상 = 긍정):\")\n    print(f\"  긍정: {interactions['label'].sum():,.0f}개 ({interactions['label'].mean()*100:.1f}%)\")\n    \n    # 샘플링\n    sample_size = config['data'].get('sample_size')\n    if sample_size and sample_size < len(interactions):\n        interactions = interactions.sample(n=sample_size, random_state=42)\n        print(f\"\\n샘플링: {sample_size:,}개\")\n    \n    # 분할\n    train_ratio = config['data']['train_ratio']\n    val_ratio = config['data']['val_ratio']\n    \n    train, temp = train_test_split(interactions, test_size=(1-train_ratio), \n                                   random_state=42, stratify=interactions['label'])\n    val_size = val_ratio / (val_ratio + config['data']['test_ratio'])\n    val, test = train_test_split(temp, test_size=(1-val_size), \n                                 random_state=42, stratify=temp['label'])\n    \n    print(f\"\\n데이터 분할:\")\n    print(f\"  Train: {len(train):,}개 ({len(train)/len(interactions)*100:.1f}%)\")\n    print(f\"  Val: {len(val):,}개 ({len(val)/len(interactions)*100:.1f}%)\")\n    print(f\"  Test: {len(test):,}개 ({len(test)/len(interactions)*100:.1f}%)\")\n    \n    # 저장\n    train.to_csv('data/train.csv', index=False)\n    val.to_csv('data/val.csv', index=False)\n    test.to_csv('data/test.csv', index=False)\n    \n    # 메타데이터\n    meta = {\n        'num_users': int(interactions['user_id'].max() + 1),\n        'num_recipes': int(interactions['recipe_id'].max() + 1),\n        'train_size': len(train),\n        'val_size': len(val),\n        'test_size': len(test)\n    }\n    \n    with open('data/meta.json', 'w') as f:\n        json.dump(meta, f, indent=2)\n    \n    print(f\"\\n저장 완료:\")\n    print(f\"  ✅ train.csv, val.csv, test.csv\")\n    print(f\"  ✅ meta.json\")\n    print(f\"\\n사용자: {meta['num_users']:,}, 레시피: {meta['num_recipes']:,}\")\n    print(\"\\n✅ 전처리 완료!\")\n\nif __name__ == \"__main__\":\n    preprocess()\nEOF\n```",
      "verificationCriteria": "`training/preprocess.py` 파일이 생성되어야 합니다."
    },
    {
      "id": "8d2fbf31-2846-44f9-b45b-7befa62f938b",
      "name": "Phase 4.2: 전처리 실행",
      "description": "작성된 전처리 스크립트를 실행하여 데이터를 처리합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:40:31.788Z",
      "updatedAt": "2025-10-30T03:40:31.788Z",
      "implementationGuide": "```bash\npython training/preprocess.py\n```",
      "verificationCriteria": "`train.csv`, `val.csv`, `test.csv`, `meta.json` 파일이 생성되어야 합니다."
    },
    {
      "id": "5d3669c4-9a75-45fe-8f96-74036e0f62af",
      "name": "Phase 4.3: Git 커밋",
      "description": "전처리 스크립트 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T03:40:37.489Z",
      "updatedAt": "2025-10-30T03:40:37.489Z",
      "implementationGuide": "```bash\ngit add training/preprocess.py\ngit commit -m \"feat: Add preprocessing script\n\n- Stratified train/val/test split\n- Binary labeling (4+ stars)\n- Saved metadata\n- Tested with 10K samples\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "207d9453-75a3-419d-b04d-e830ec83362e",
      "name": "Phase 5.1: training/utils.py 작성",
      "description": "학습 및 평가에 사용될 유틸리티 함수(train_epoch, evaluate, EarlyStopping)를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:15:53.541Z",
      "updatedAt": "2025-10-30T04:15:53.541Z",
      "implementationGuide": "```bash\ncat > training/utils.py << 'EOF'\nimport torch\nfrom tqdm import tqdm\nfrom sklearn.metrics import roc_auc_score, average_precision_score\nimport numpy as np\n\ndef train_epoch(model, loader, criterion, optimizer, device):\n    model.train()\n    total_loss = 0\n    \n    for batch in tqdm(loader, desc=\"Training\", leave=False):\n        user_ids = batch['user_id'].to(device)\n        recipe_ids = batch['recipe_id'].to(device)\n        labels = batch['label'].to(device)\n        \n        optimizer.zero_grad()\n        outputs = model(user_ids, recipe_ids)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        total_loss += loss.item()\n    \n    return total_loss / len(loader)\n\ndef evaluate(model, loader, criterion, device):\n    model.eval()\n    total_loss = 0\n    all_preds = []\n    all_labels = []\n    \n    with torch.no_grad():\n        for batch in tqdm(loader, desc=\"Evaluating\", leave=False):\n            user_ids = batch['user_id'].to(device)\n            recipe_ids = batch['recipe_id'].to(device)\n            labels = batch['label'].to(device)\n            \n            outputs = model(user_ids, recipe_ids)\n            loss = criterion(outputs, labels)\n            \n            total_loss += loss.item()\n            all_preds.extend(outputs.cpu().numpy())\n            all_labels.extend(labels.cpu().numpy())\n    \n    auc = roc_auc_score(all_labels, all_preds)\n    ap = average_precision_score(all_labels, all_preds)\n    \n    return {\n        'loss': total_loss / len(loader),\n        'auc': auc,\n        'ap': ap\n    }\n\nclass EarlyStopping:\n    def __init__(self, patience=3, min_delta=0.0, mode='max'):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.mode = mode\n        self.counter = 0\n        self.best_score = None\n        self.early_stop = False\n    \n    def __call__(self, score):\n        if self.best_score is None:\n            self.best_score = score\n            return False\n        \n        if self.mode == 'max':\n            if score > self.best_score + self.min_delta:\n                self.best_score = score\n                self.counter = 0\n            else:\n                self.counter += 1\n        else:\n            if score < self.best_score - self.min_delta:\n                self.best_score = score\n                self.counter = 0\n            else:\n                self.counter += 1\n        \n        if self.counter >= self.patience:\n            self.early_stop = True\n            return True\n        \n        return False\n\nif __name__ == \"__main__\":\n    print(\"✅ Utils test passed!\")\nEOF\n\npython training/utils.py\n```",
      "verificationCriteria": "\"✅ Utils test passed!\"가 출력되어야 합니다."
    },
    {
      "id": "c0293bd1-63c3-441d-8db9-3bf9674bcf98",
      "name": "Phase 5.1: training/utils.py 작성",
      "description": "학습 및 평가에 사용될 유틸리티 함수(train_epoch, evaluate, EarlyStopping)를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:05.231Z",
      "updatedAt": "2025-10-30T04:17:05.231Z",
      "implementationGuide": "```bash\ncat > training/utils.py << 'EOF'\nimport torch\nfrom tqdm import tqdm\nfrom sklearn.metrics import roc_auc_score, average_precision_score\nimport numpy as np\n\ndef train_epoch(model, loader, criterion, optimizer, device):\n    model.train()\n    total_loss = 0\n    \n    for batch in tqdm(loader, desc=\"Training\", leave=False):\n        user_ids = batch['user_id'].to(device)\n        recipe_ids = batch['recipe_id'].to(device)\n        labels = batch['label'].to(device)\n        \n        optimizer.zero_grad()\n        outputs = model(user_ids, recipe_ids)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n        \n        total_loss += loss.item()\n    \n    return total_loss / len(loader)\n\ndef evaluate(model, loader, criterion, device):\n    model.eval()\n    total_loss = 0\n    all_preds = []\n    all_labels = []\n    \n    with torch.no_grad():\n        for batch in tqdm(loader, desc=\"Evaluating\", leave=False):\n            user_ids = batch['user_id'].to(device)\n            recipe_ids = batch['recipe_id'].to(device)\n            labels = batch['label'].to(device)\n            \n            outputs = model(user_ids, recipe_ids)\n            loss = criterion(outputs, labels)\n            \n            total_loss += loss.item()\n            all_preds.extend(outputs.cpu().numpy())\n            all_labels.extend(labels.cpu().numpy())\n    \n    auc = roc_auc_score(all_labels, all_preds)\n    ap = average_precision_score(all_labels, all_preds)\n    \n    return {\n        'loss': total_loss / len(loader),\n        'auc': auc,\n        'ap': ap\n    }\n\nclass EarlyStopping:\n    def __init__(self, patience=3, min_delta=0.0, mode='max'):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.mode = mode\n        self.counter = 0\n        self.best_score = None\n        self.early_stop = False\n    \n    def __call__(self, score):\n        if self.best_score is None:\n            self.best_score = score\n            return False\n        \n        if self.mode == 'max':\n            if score > self.best_score + self.min_delta:\n                self.best_score = score\n                self.counter = 0\n            else:\n                self.counter += 1\n        else:\n            if score < self.best_score - self.min_delta:\n                self.best_score = score\n                self.counter = 0\n            else:\n                self.counter += 1\n        \n        if self.counter >= self.patience:\n            self.early_stop = True\n            return True\n        \n        return False\n\nif __name__ == \"__main__\":\n    print(\"✅ Utils test passed!\")\nEOF\n\npython training/utils.py\n```",
      "verificationCriteria": "\"✅ Utils test passed!\"가 출력되어야 합니다."
    },
    {
      "id": "8dba3daa-598d-43d9-92aa-d072ec9f7d31",
      "name": "Phase 5.2: training/train.py 작성",
      "description": "모델 학습 파이프라인을 구성하는 `train.py` 스크립트를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:21.716Z",
      "updatedAt": "2025-10-30T04:17:21.716Z",
      "implementationGuide": "```bash\ncat > training/train.py << 'EOF'\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nimport pandas as pd\nimport yaml\nimport json\nimport sys\nimport os\nfrom datetime import datetime\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom models.ncf_model import NCF\nfrom models.dataset import RecipeNCFDataset\nfrom training.utils import train_epoch, evaluate, EarlyStopping\n\ndef load_config():\n    with open('configs/config.yaml') as f:\n        return yaml.safe_load(f)\n\ndef load_metadata():\n    with open('data/meta.json') as f:\n        return json.load(f)\n\ndef setup_device():\n    if torch.backends.mps.is_available():\n        device = torch.device(\"mps\")\n        print(\"✅ MPS (Apple Silicon)\")\n    elif torch.cuda.is_available():\n        device = torch.device(\"cuda\")\n        print(\"✅ CUDA\")\n    else:\n        device = torch.device(\"cpu\")\n        print(\"ℹ️  CPU\")\n    return device\n\ndef main():\n    print(\"=\"*80)\n    print(\"🔥 NCF Training\")\n    print(\"=\"*80)\n    \n    config = load_config()\n    meta = load_metadata()\n    device = setup_device()\n    \n    # 데이터\n    print(\"\\n데이터 로딩...\")\n    train_df = pd.read_csv('data/train.csv')\n    val_df = pd.read_csv('data/val.csv')\n    test_df = pd.read_csv('data/test.csv')\n    \n    train_dataset = RecipeNCFDataset(train_df)\n    val_dataset = RecipeNCFDataset(val_df)\n    test_dataset = RecipeNCFDataset(test_df)\n    \n    train_loader = DataLoader(train_dataset, batch_size=config['training']['batch_size'], shuffle=True)\n    val_loader = DataLoader(val_dataset, batch_size=config['training']['batch_size'])\n    test_loader = DataLoader(test_dataset, batch_size=config['training']['batch_size'])\n    \n    # 모델\n    print(\"\\n모델 생성...\")\n    model = NCF(\n        num_users=meta['num_users'],\n        num_recipes=meta['num_recipes'],\n        embedding_dim=config['model']['embedding_dim'],\n        mlp_layers=config['model']['mlp_layers'],\n        dropout=config['model']['dropout']\n    ).to(device)\n    \n    info = model.get_model_info()\n    print(f\"  파라미터: {info['total_params']:,}개\")\n    \n    # 학습\n    criterion = nn.BCELoss()\n    optimizer = optim.Adam(model.parameters(), lr=config['training']['learning_rate'],\n                          weight_decay=config['training']['weight_decay'])\n    early_stopping = EarlyStopping(patience=config['training']['early_stopping_patience'])\n    \n    best_auc = 0\n    history = {'train_loss': [], 'val_auc': []}\n    \n    print(\"\\n학습 시작!\")\n    print(\"=\"*80)\n    \n    for epoch in range(config['training']['epochs']):\n        print(f\"\\nEpoch {epoch+1}/{config['training']['epochs']}\")\n        \n        train_loss = train_epoch(model, train_loader, criterion, optimizer, device)\n        val_metrics = evaluate(model, val_loader, criterion, device)\n        \n        history['train_loss'].append(train_loss)\n        history['val_auc'].append(val_metrics['auc'])\n        \n        print(f\"  Train Loss: {train_loss:.4f}\")\n        print(f\"  Val AUC: {val_metrics['auc']:.4f}\")\n        \n        if val_metrics['auc'] > best_auc:\n            best_auc = val_metrics['auc']\n            torch.save(model.state_dict(), 'checkpoints/best_model.pth')\n            print(f\"  ✅ Best model saved! (AUC: {best_auc:.4f})\")\n        \n        if early_stopping(val_metrics['auc']):\n            print(f\"\\n⏹️  Early stopping\")\n            break\n    \n    # 테스트\n    print(\"\\n테스트 평가\")\n    print(\"=\"*80)\n    model.load_state_dict(torch.load('checkpoints/best_model.pth'))\n    test_metrics = evaluate(model, test_loader, criterion, device)\n    \n    print(f\"\\nTest AUC: {test_metrics['auc']:.4f}\")\n    print(f\"Test AP: {test_metrics['ap']:.4f}\")\n    \n    # 결과 저장\n    results = {\n        'timestamp': datetime.now().strftime(\"%Y%m%d_%H%M%S\"),\n        'test_metrics': test_metrics,\n        'best_val_auc': best_auc,\n        'history': history\n    }\n    \n    with open(f'checkpoints/results_{results[\"timestamp\"]}.json', 'w') as f:\n        json.dump(results, f, indent=2)\n    \n    print(\"\\n✅ 학습 완료!\")\n    print(f\"  Best Val AUC: {best_auc:.4f}\")\n    print(f\"  Test AUC: {test_metrics['auc']:.4f}\")\n\nif __name__ == \"__main__\":\n    main()\nEOF\n```",
      "verificationCriteria": "`training/train.py` 파일이 생성되어야 합니다."
    },
    {
      "id": "7c6dd0f4-994a-4937-969d-7b1ba7ecce76",
      "name": "Phase 5.3: 첫 학습 실행",
      "description": "작성된 학습 스크립트를 실행하여 모델을 처음으로 학습시킵니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:27.823Z",
      "updatedAt": "2025-10-30T04:17:27.823Z",
      "implementationGuide": "```bash\npython training/train.py\n```",
      "verificationCriteria": "`✅ 학습 완료!`가 출력되고, `checkpoints/best_model.pth` 파일이 생성되며, Test AUC가 0.80 이상이어야 합니다."
    },
    {
      "id": "d0c7008b-6782-41e5-a2c2-0af3be99b70f",
      "name": "Phase 5.4: Git 커밋",
      "description": "학습 파이프라인 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:33.019Z",
      "updatedAt": "2025-10-30T04:17:33.019Z",
      "implementationGuide": "```bash\ngit add training/\ngit commit -m \"feat: Add training pipeline\n\n- Implemented train_epoch and evaluate\n- Added early stopping\n- Saved best model\n- Achieved Test AUC: 0.85+\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "62f13249-046c-4f37-a246-731c03637bb1",
      "name": "Phase 6.1: api 패키지 초기화",
      "description": "FastAPI API를 위한 `api` 패키지를 초기화하고 필요한 파일을 생성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:38.295Z",
      "updatedAt": "2025-10-30T04:17:38.295Z",
      "implementationGuide": "```bash\ncat > api/__init__.py << 'EOF'\n\"\"\"\nFastAPI 추천 시스템 API\n\"\"\"\nEOF\n\ntouch api/main.py\ntouch api/inference.py\ntouch api/schemas.py\n```",
      "verificationCriteria": "api 폴더 내에 `__init__.py`, `main.py`, `inference.py`, `schemas.py` 파일이 생성되어야 합니다."
    },
    {
      "id": "adc99819-1fd4-40f7-bc4e-29ba3a3a7aeb",
      "name": "Phase 6.2: Pydantic 스키마 작성",
      "description": "API 요청 및 응답을 위한 Pydantic 스키마를 정의합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:17:46.510Z",
      "updatedAt": "2025-10-30T04:17:46.510Z",
      "implementationGuide": "```bash\ncat > api/schemas.py << 'EOF'\n\"\"\"\nAPI 요청/응답 스키마\n\"\"\"\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional\n\nclass RecommendationRequest(BaseModel):\n    user_id: int = Field(..., description=\"사용자 ID\", ge=0)\n    top_k: int = Field(10, description=\"추천할 레시피 수\", ge=1, le=100)\n    exclude_rated: bool = Field(True, description=\"이미 평가한 레시피 제외\")\n\nclass RecipeInfo(BaseModel):\n    recipe_id: int\n    recipe_name: str\n    score: float = Field(..., description=\"추천 점수 (0-1)\")\n    ingredients: Optional[List[str]] = None\n    cooking_time: Optional[int] = None\n    avg_rating: Optional[float] = None\n\nclass RecommendationResponse(BaseModel):\n    user_id: int\n    recommendations: List[RecipeInfo]\n    total_count: int\n\nclass HealthResponse(BaseModel):\n    status: str\n    model_loaded: bool\n    num_users: int\n    num_recipes: int\n    device: str\n\nclass ErrorResponse(BaseModel):\n    error: str\n    detail: Optional[str] = None\n\nif __name__ == \"__main__\":\n    # 테스트\n    req = RecommendationRequest(user_id=42, top_k=5)\n    print(f\"Request: {req}\")\n    \n    recipe = RecipeInfo(\n        recipe_id=123,\n        recipe_name=\"Chocolate Chip Cookies\",\n        score=0.95,\n        cooking_time=30\n    )\n    print(f\"Recipe: {recipe}\")\n    print(\"✅ Schemas test passed!\")\nEOF\n\npython api/schemas.py\n```",
      "verificationCriteria": "\"✅ Schemas test passed!\"가 출력되어야 합니다."
    },
    {
      "id": "e1df4cfd-10be-4d7c-b1a0-1e3706323783",
      "name": "Phase 6.3: 추론 로직 작성",
      "description": "추천 모델을 로드하고 사용자에게 레시피를 추천하는 추론 로직을 구현합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:18:08.908Z",
      "updatedAt": "2025-10-30T04:18:08.908Z",
      "implementationGuide": "```bash\ncat > api/inference.py << 'EOF'\n\"\"\"\n추천 추론 로직\n\"\"\"\nimport torch\nimport pandas as pd\nimport json\nimport sys\nimport os\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom models.ncf_model import NCF\n\nclass RecipeRecommender:\n    def __init__(self, model_path='checkpoints/best_model.pth',\n                 meta_path='data/meta.json',\n                 recipes_path='data/RAW_recipes.csv',\n                 interactions_path='data/RAW_interactions.csv'):\n        \n        print(\"=\"*80)\n        print(\"추천 시스템 초기화\")\n        print(\"=\"*80)\n        \n        # 메타데이터 로드\n        with open(meta_path) as f:\n            self.meta = json.load(f)\n        \n        print(f\"\\n메타데이터:\")\n        print(f\"  사용자: {self.meta['num_users']:,}명\")\n        print(f\"  레시피: {self.meta['num_recipes']:,}개\")\n        \n        # Device 설정\n        if torch.backends.mps.is_available():\n            self.device = torch.device(\"mps\")\n            print(f\"\\n✅ MPS 사용\")\n        elif torch.cuda.is_available():\n            self.device = torch.device(\"cuda\")\n            print(f\"\\n✅ CUDA 사용\")\n        else:\n            self.device = torch.device(\"cpu\")\n            print(f\"\\nℹ️  CPU 사용\")\n        \n        # 모델 로드\n        print(f\"\\n모델 로딩: {model_path}\")\n        self.model = NCF(\n            num_users=self.meta['num_users'],\n            num_recipes=self.meta['num_recipes'],\n            embedding_dim=32,\n            mlp_layers=[64, 32, 16]\n        )\n        self.model.load_state_dict(torch.load(model_path, map_location=self.device))\n        self.model.to(self.device)\n        self.model.eval()\n        print(\"  ✅ 모델 로드 완료\")\n        \n        # 레시피 데이터 로드\n        print(f\"\\n레시피 데이터 로딩: {recipes_path}\")\n        self.recipes_df = pd.read_csv(recipes_path)\n        print(f\"  ✅ {len(self.recipes_df):,}개 레시피\")\n        \n        # 상호작용 데이터 로드 (이미 평가한 레시피 제외용)\n        print(f\"\\n상호작용 데이터 로딩: {interactions_path}\")\n        self.interactions_df = pd.read_csv(interactions_path)\n        print(f\"  ✅ {len(self.interactions_df):,}개 상호작용\")\n        \n        # 사용자별 평가한 레시피 캐싱\n        self.user_rated_recipes = self.interactions_df.groupby('user_id')['recipe_id'].apply(set).to_dict()\n        \n        print(\"\\n\" + \"=\"*80)\n        print(\"✅ 추천 시스템 준비 완료!\")\n        print(\"=\"*80)\n    \n    def get_user_rated_recipes(self, user_id):\n        \"\"\"사용자가 이미 평가한 레시피 ID 집합 반환\"\"\"\n        return self.user_rated_recipes.get(user_id, set())\n    \n    def predict_batch(self, user_id, recipe_ids):\n        \"\"\"배치 예측\"\"\"\n        batch_size = len(recipe_ids)\n        user_ids = torch.tensor([user_id] * batch_size, dtype=torch.long).to(self.device)\n        recipe_ids_tensor = torch.tensor(recipe_ids, dtype=torch.long).to(self.device)\n        \n        with torch.no_grad():\n            predictions = self.model(user_ids, recipe_ids_tensor).cpu().numpy()\n        \n        return predictions\n    \n    def recommend(self, user_id, top_k=10, exclude_rated=True):\n        \"\"\"\n        사용자에게 Top-K 레시피 추천\n        \n        Args:\n            user_id: 사용자 ID\n            top_k: 추천할 레시피 수\n            exclude_rated: 이미 평가한 레시피 제외 여부\n        \n        Returns:\n            list of dict: 추천 레시피 정보\n        \"\"\"\n        # 모든 레시피 ID\n        all_recipe_ids = list(range(self.meta['num_recipes']))\n        \n        # 이미 평가한 레시피 제외\n        if exclude_rated:\n            rated_recipes = self.get_user_rated_recipes(user_id)\n            candidate_recipes = [rid for rid in all_recipe_ids if rid not in rated_recipes]\n        else:\n            candidate_recipes = all_recipe_ids\n        \n        if len(candidate_recipes) == 0:\n            return []\n        \n        # 배치로 예측 (메모리 효율)\n        batch_size = 1000\n        all_scores = []\n        all_recipe_ids = []\n        \n        for i in range(0, len(candidate_recipes), batch_size):\n            batch_recipes = candidate_recipes[i:i+batch_size]\n            scores = self.predict_batch(user_id, batch_recipes)\n            all_scores.extend(scores)\n            all_recipe_ids.extend(batch_recipes)\n        \n        # Top-K 선택\n        top_indices = sorted(range(len(all_scores)), key=lambda i: all_scores[i], reverse=True)[:top_k]\n        \n        # 결과 생성\n        recommendations = []\n        for idx in top_indices:\n            recipe_id = all_recipe_ids[idx]\n            score = float(all_scores[idx])\n            \n            # 레시피 상세 정보\n            recipe_row = self.recipes_df[self.recipes_df['id'] == recipe_id]\n            if len(recipe_row) == 0:\n                continue\n            \n            recipe_row = recipe_row.iloc[0]\n            \n            recommendations.append({\n                'recipe_id': int(recipe_id),\n                'recipe_name': str(recipe_row['name']),\n                'score': score,\n                'cooking_time': int(recipe_row['minutes']) if pd.notna(recipe_row['minutes']) else None,\n                'ingredients': eval(recipe_row['ingredients']) if pd.notna(recipe_row['ingredients']) else None,\n                'n_ingredients': int(recipe_row['n_ingredients']) if pd.notna(recipe_row['n_ingredients']) else None\n            })\n        \n        return recommendations\n    \n    def get_popular_recipes(self, top_k=10):\n        \"\"\"인기 레시피 반환 (Cold Start용)\"\"\"\n        recipe_ratings = self.interactions_df.groupby('recipe_id').agg({\n            'rating': ['mean', 'count']\n        }).reset_index()\n        recipe_ratings.columns = ['recipe_id', 'avg_rating', 'count']\n        \n        # 최소 10개 이상 평가받은 레시피\n        popular = recipe_ratings[recipe_ratings['count'] >= 10]\n        popular = popular.sort_values('avg_rating', ascending=False).head(top_k)\n        \n        recommendations = []\n        for _, row in popular.iterrows():\n            recipe_id = int(row['recipe_id'])\n            recipe_row = self.recipes_df[self.recipes_df['id'] == recipe_id]\n            \n            if len(recipe_row) == 0:\n                continue\n            \n            recipe_row = recipe_row.iloc[0]\n            recommendations.append({\n                'recipe_id': recipe_id,\n                'recipe_name': str(recipe_row['name']),\n                'score': float(row['avg_rating']) / 5.0,  # 0-1 스케일로 정규화\n                'cooking_time': int(recipe_row['minutes']) if pd.notna(recipe_row['minutes']) else None,\n                'avg_rating': float(row['avg_rating'])\n            })\n        \n        return recommendations\n\nif __name__ == \"__main__\":\n    # 테스트\n    recommender = RecipeRecommender()\n    \n    print(\"\\n\" + \"=\"*80)\n    print(\"추천 테스트\")\n    print(\"=\"*80)\n    \n    # 사용자 42에게 추천\n    user_id = 42\n    recommendations = recommender.recommend(user_id, top_k=5)\n    \n    print(f\"\\n사용자 {user_id}를 위한 추천:\")\n    for i, rec in enumerate(recommendations, 1):\n        print(f\"\\n{i}. {rec['recipe_name']}\")\n        print(f\"   점수: {rec['score']:.4f}\")\n        print(f\"   조리시간: {rec['cooking_time']}분\")\n        print(f\"   재료: {rec['n_ingredients']}개\")\n    \n    print(\"\\n✅ Inference test passed!\")\nEOF\n\npython api/inference.py\n```",
      "verificationCriteria": "\"✅ Inference test passed!\" 및 추천 결과가 출력되어야 합니다."
    },
    {
      "id": "74a2bcf2-34fd-4247-b9db-56af724dec27",
      "name": "Phase 6.4: Git 커밋",
      "description": "추천 추론 로직 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:18:14.231Z",
      "updatedAt": "2025-10-30T04:18:14.231Z",
      "implementationGuide": "```bash\ngit add api/schemas.py api/inference.py\ngit commit -m \"feat: Add recommendation inference logic\n\n- Implemented RecipeRecommender class\n- Added batch prediction\n- Added popular recipe fallback\n- Tested recommendation generation\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "0935e7a5-6762-4f74-ba23-2d170731027c",
      "name": "Phase 7.1: FastAPI 메인 서버 작성",
      "description": "FastAPI 애플리케이션의 메인 서버 로직을 작성합니다. 추천 시스템 로드, CORS 설정, API 엔드포인트 정의 등을 포함합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:18:33.198Z",
      "updatedAt": "2025-10-30T04:18:33.198Z",
      "implementationGuide": "```bash\ncat > api/main.py << 'EOF'\n\"\"\"\nFastAPI 추천 시스템 서버\n\"\"\"\nfrom fastapi import FastAPI, HTTPException, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nimport uvicorn\nimport sys\nimport os\nfrom contextlib import asynccontextmanager\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom api.schemas import (\n    RecommendationRequest,\n    RecommendationResponse,\n    RecipeInfo,\n    HealthResponse,\n    ErrorResponse\n)\nfrom api.inference import RecipeRecommender\n\n# 전역 추천 시스템\nrecommender = None\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    global recommender\n    print(\"\\n\" + \"=\"*80)\n    print(\"FastAPI 서버 시작\")\n    print(\"=\"*80)\n    \n    try:\n        recommender = RecipeRecommender()\n        print(\"\\n✅ 추천 시스템 로드 완료\")\n    except Exception as e:\n        print(f\"\\n❌ 추천 시스템 로드 실패: {e}\")\n        recommender = None\n    \n    yield\n    \n    # Shutdown\n    print(\"\\n\" + \"=\"*80)\n    print(\"FastAPI 서버 종료\")\n    print(\"=\"*80)\n\n# FastAPI 앱\napp = FastAPI(\n    title=\"Recipe Recommendation API\",\n    description=\"NCF 기반 레시피 추천 시스템\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# CORS 설정\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        \"http://localhost:3000\",\n        \"http://localhost:3001\",\n        \"http://localhost:8080\"\n    ],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"]\n)\n\n@app.get(\"/\", tags=[\"Root\"])\nasync def root():\n    \"\"\"API 루트\"\"\"\n    return {\n        \"message\": \"Recipe Recommendation API\",\n        \"version\": \"1.0.0\",\n        \"docs\": \"/docs\",\n        \"health\": \"/health\"\n    }\n\n@app.get(\"/health\", response_model=HealthResponse, tags=[\"Health\"])\nasync def health_check():\n    \"\"\"서버 상태 확인\"\"\"\n    if recommender is None:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Recommender not loaded\"\n        )\n    \n    return HealthResponse(\n        status=\"healthy\",\n        model_loaded=True,\n        num_users=recommender.meta['num_users'],\n        num_recipes=recommender.meta['num_recipes'],\n        device=str(recommender.device)\n    )\n\n@app.post(\"/recommend\", response_model=RecommendationResponse, tags=[\"Recommendation\"])\nasync def get_recommendations(request: RecommendationRequest):\n    \"\"\"\n    레시피 추천 API\n    \n    - **user_id**: 사용자 ID\n    - **top_k**: 추천할 레시피 수 (기본: 10)\n    - **exclude_rated**: 이미 평가한 레시피 제외 (기본: True)\n    \"\"\"\n    if recommender is None:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Recommender not loaded\"\n        )\n    \n    # 사용자 ID 검증\n    if request.user_id < 0 or request.user_id >= recommender.meta['num_users']:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Invalid user_id. Must be 0-{recommender.meta['num_users']-1}\"\n        )\n    \n    try:\n        # 추천 생성\n        recommendations = recommender.recommend(\n            user_id=request.user_id,\n            top_k=request.top_k,\n            exclude_rated=request.exclude_rated\n        )\n        \n        # 응답 생성\n        recipe_infos = [RecipeInfo(**rec) for rec in recommendations]\n        \n        return RecommendationResponse(\n            user_id=request.user_id,\n            recommendations=recipe_infos,\n            total_count=len(recipe_infos)\n        )\n    \n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Recommendation failed: {str(e)}\"\n        )\n\n@app.get(\"/popular\", response_model=RecommendationResponse, tags=[\"Recommendation\"])\nasync def get_popular_recipes(top_k: int = 10):\n    \"\"\"\n    인기 레시피 조회 (Cold Start용)\n    \n    - **top_k**: 조회할 레시피 수 (기본: 10)\n    \"\"\"\n    if recommender is None:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Recommender not loaded\"\n        )\n    \n    try:\n        recommendations = recommender.get_popular_recipes(top_k=top_k)\n        recipe_infos = [RecipeInfo(**rec) for rec in recommendations]\n        \n        return RecommendationResponse(\n            user_id=-1,  # 특정 사용자가 아님\n            recommendations=recipe_infos,\n            total_count=len(recipe_infos)\n        )\n    \n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to get popular recipes: {str(e)}\"\n        )\n\n@app.get(\"/recipe/{recipe_id}\", tags=[\"Recipe\"])\nasync def get_recipe_info(recipe_id: int):\n    \"\"\"레시피 상세 정보\"\"\"\n    if recommender is None:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Recommender not loaded\"\n        )\n    \n    recipe_row = recommender.recipes_df[recommender.recipes_df['id'] == recipe_id]\n    \n    if len(recipe_row) == 0:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Recipe {recipe_id} not found\"\n        )\n    \n    recipe = recipe_row.iloc[0]\n    \n    return {\n        'recipe_id': int(recipe_id),\n        'name': str(recipe['name']),\n        'minutes': int(recipe['minutes']) if pd.notna(recipe['minutes']) else None,\n        'n_steps': int(recipe['n_steps']) if pd.notna(recipe['n_steps']) else None,\n        'n_ingredients': int(recipe['n_ingredients']) if pd.notna(recipe['n_ingredients']) else None,\n        'description': str(recipe['description']) if pd.notna(recipe['description']) else None\n    }\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request, exc):\n    \"\"\"전역 예외 처리\"\"\"\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"error\": \"Internal server error\", \"detail\": str(exc)}\n    )\n\nif __name__ == \"__main__\":\n    print(\"\\n\" + \"=\"*80)\n    print(\"🚀 FastAPI 서버 실행\")\n    print(\"=\"*80)\n    print(\"\\n서버 주소: http://localhost:8000\")\n    print(\"API 문서: http://localhost:8000/docs\")\n    print(\"Health Check: http://localhost:8000/health\")\n    print(\"\\n종료: Ctrl+C\")\n    print(\"=\"*80 + \"\\n\")\n    \n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True,\n        log_level=\"info\"\n    )\nEOF\n```",
      "verificationCriteria": "api/main.py 파일이 생성되어야 합니다."
    },
    {
      "id": "5d460dbf-881c-4655-8f7d-e17f2932abc4",
      "name": "Phase 7.2: API 서버 실행 테스트",
      "description": "FastAPI 서버를 실행하고 `curl` 명령 또는 브라우저를 통해 API 엔드포인트를 테스트합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:18:39.285Z",
      "updatedAt": "2025-10-30T04:18:39.285Z",
      "implementationGuide": "```bash\n# 서버 실행\ncd api\npython main.py\n\n# 또는\n# uvicorn api.main:app --reload\n```\n\n**별도 터미널에서 테스트**:\n```bash\n# Health Check\ncurl http://localhost:8000/health\n\n# 추천 요청\ncurl -X POST http://localhost:8000/recommend \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"user_id\": 42, \"top_k\": 5}'\n\n# 인기 레시피\ncurl http://localhost:8000/popular?top_k=5\n\n# 레시피 상세\ncurl http://localhost:8000/recipe/137739\n```\n\n**또는 브라우저에서**:\n- http://localhost:8000/docs (Swagger UI)\n- http://localhost:8000/health",
      "verificationCriteria": "서버가 정상적으로 실행되고, `/health` 엔드포인트가 200 OK 응답을 반환하며, `/recommend` 엔드포인트가 정상적으로 작동해야 합니다."
    },
    {
      "id": "7ea20a68-d542-45f7-a4a5-73f4fe721185",
      "name": "Phase 7.3: API 테스트 스크립트 작성",
      "description": "FastAPI 서버의 엔드포인트를 자동으로 테스트하는 Python 스크립트를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:19:12.124Z",
      "updatedAt": "2025-10-30T04:19:12.124Z",
      "implementationGuide": "```bash\ncat > tests/test_api.py << 'EOF'\n\"\"\"\nAPI 테스트 스크립트\n\"\"\"\nimport requests\nimport json\n\nBASE_URL = \"http://localhost:8000\"\n\ndef test_health():\n    \"\"\"Health Check 테스트\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"Test 1: Health Check\")\n    print(\"=\"*80)\n    \n    response = requests.get(f\"{BASE_URL}/health\")\n    print(f\"Status: {response.status_code}\")\n    print(f\"Response: {json.dumps(response.json(), indent=2)}\")\n    \n    assert response.status_code == 200\n    assert response.json()['model_loaded'] == True\n    print(\"✅ Health check passed!\")\n\ndef test_recommend():\n    \"\"\"추천 API 테스트\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"Test 2: Recommendation\")\n    print(\"=\"*80)\n    \n    payload = {\n        \"user_id\": 42,\n        \"top_k\": 5,\n        \"exclude_rated\": True\n    }\n    \n    response = requests.post(f\"{BASE_URL}/recommend\", json=payload)\n    print(f\"Status: {response.status_code}\")\n    \n    data = response.json()\n    print(f\"\\nUser ID: {data['user_id']}\")\n    print(f\"Total recommendations: {data['total_count']}\")\n    print(\"\\nTop 3 recommendations:\")\n    \n    for i, rec in enumerate(data['recommendations'][:3], 1):\n        print(f\"\\n{i}. {rec['recipe_name']}\")\n        print(f\"   Score: {rec['score']:.4f}\")\n        print(f\"   Time: {rec['cooking_time']}분\")\n    \n    assert response.status_code == 200\n    assert data['total_count'] > 0\n    print(\"\\n✅ Recommendation test passed!\")\n\ndef test_popular():\n    \"\"\"인기 레시피 API 테스트\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"Test 3: Popular Recipes\")\n    print(\"=\"*80)\n    \n    response = requests.get(f\"{BASE_URL}/popular?top_k=3\")\n    print(f\"Status: {response.status_code}\")\n    \n    data = response.json()\n    print(f\"\\nTotal popular recipes: {data['total_count']}\")\n    \n    for i, rec in enumerate(data['recommendations'], 1):\n        print(f\"\\n{i}. {rec['recipe_name']}\")\n        print(f\"   Score: {rec['score']:.4f}\")\n        if rec.get('avg_rating'):\n            print(f\"   Avg Rating: {rec['avg_rating']:.2f}/5\")\n    \n    assert response.status_code == 200\n    print(\"\\n✅ Popular recipes test passed!\")\n\ndef test_recipe_detail():\n    \"\"\"레시피 상세 API 테스트\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"Test 4: Recipe Detail\")\n    print(\"=\"*80)\n    \n    recipe_id = 137739\n    response = requests.get(f\"{BASE_URL}/recipe/{recipe_id}\")\n    print(f\"Status: {response.status_code}\")\n    \n    data = response.json()\n    print(f\"\\nRecipe: {data['name']}\")\n    print(f\"Time: {data['minutes']}분\")\n    print(f\"Steps: {data['n_steps']}개\")\n    print(f\"Ingredients: {data['n_ingredients']}개\")\n    \n    assert response.status_code == 200\n    print(\"\\n✅ Recipe detail test passed!\")\n\ndef test_error_cases():\n    \"\"\"에러 케이스 테스트\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"Test 5: Error Cases\")\n    print(\"=\"*80)\n    \n    # 잘못된 user_id\n    payload = {\"user_id\": 9999999, \"top_k\": 5}\n    response = requests.post(f\"{BASE_URL}/recommend\", json=payload)\n    print(f\"\\n잘못된 user_id: Status {response.status_code}\")\n    assert response.status_code == 400\n    \n    # 존재하지 않는 recipe_id\n    response = requests.get(f\"{BASE_URL}/recipe/9999999\")\n    print(f\"존재하지 않는 recipe: Status {response.status_code}\")\n    assert response.status_code == 404\n    \n    print(\"\\n✅ Error cases test passed!\")\n\nif __name__ == \"__main__\":\n    print(\"=\"*80)\n    print(\"🧪 API 테스트 시작\")\n    print(\"=\"*80)\n    print(\"\\n⚠️  서버가 실행 중이어야 합니다: python api/main.py\")\n    \n    try:\n        test_health()\n        test_recommend()\n        test_popular()\n        test_recipe_detail()\n        test_error_cases()\n        \n        print(\"\\n\" + \"=\"*80)\n        print(\"✅ 모든 테스트 통과!\")\n        print(\"=\"*80)\n    \n    except requests.exceptions.ConnectionError:\n        print(\"\\n❌ 서버 연결 실패. 서버를 먼저 실행하세요.\")\n    except AssertionError as e:\n        print(f\"\\n❌ 테스트 실패: {e}\")\n    except Exception as e:\n        print(f\"\\n❌ 예외 발생: {e}\")\nEOF\n\n# 서버가 실행 중일 때 테스트\npython tests/test_api.py\n```",
      "verificationCriteria": "\"✅ 모든 테스트 통과!\"가 출력되어야 합니다."
    },
    {
      "id": "c112ddb6-280f-48a1-b809-45dde0f6f70f",
      "name": "Phase 7.4: Git 커밋",
      "description": "FastAPI 서버 및 테스트 코드 추가에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:19:42.262Z",
      "updatedAt": "2025-10-30T04:19:42.262Z",
      "implementationGuide": "```bash\ngit add api/ tests/\ngit commit -m \"feat: Add FastAPI server and tests\n\n- Implemented REST API endpoints\n- Added /recommend, /popular, /recipe endpoints\n- Added CORS middleware\n- Created comprehensive test suite\n- Tested all endpoints successfully\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "36f7d6a2-cbb6-411b-9bac-4aa4d0d75e99",
      "name": "Phase 8.1: TypeScript API 클라이언트 작성",
      "description": "FastAPI 서버와 통신하기 위한 TypeScript API 클라이언트 모듈을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:20:24.327Z",
      "updatedAt": "2025-10-30T04:20:24.327Z",
      "implementationGuide": "```bash\nmkdir -p frontend/src\n\ncat > frontend/src/recipeApi.ts << 'EOF'\n/**\n * Recipe Recommendation API Client\n */\n\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n\nexport interface Recipe {\n  recipe_id: number;\n  recipe_name: string;\n  score: number;\n  ingredients?: string[];\n  cooking_time?: number;\n  avg_rating?: number;\n  n_ingredients?: number;\n}\n\nexport interface RecommendationRequest {\n  user_id: number;\n  top_k?: number;\n  exclude_rated?: boolean;\n}\n\nexport interface RecommendationResponse {\n  user_id: number;\n  recommendations: Recipe[];\n  total_count: number;\n}\n\nexport interface HealthResponse {\n  status: string;\n  model_loaded: boolean;\n  num_users: number;\n  num_recipes: number;\n  device: string;\n}\n\nexport class RecipeApiClient {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = API_BASE_URL) {\n    this.baseUrl = baseUrl;\n  }\n\n  /**\n   * Health Check\n   */\n  async checkHealth(): Promise<HealthResponse> {\n    const response = await fetch(`${this.baseUrl}/health`);\n    if (!response.ok) {\n      throw new Error(`Health check failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n\n  /**\n   * 레시피 추천\n   */\n  async getRecommendations(\n    request: RecommendationRequest\n  ): Promise<RecommendationResponse> {\n    const response = await fetch(`${this.baseUrl}/recommend`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(request),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.detail || 'Recommendation failed');\n    }\n\n    return response.json();\n  }\n\n  /**\n   * 인기 레시피\n   */\n  async getPopularRecipes(topK: number = 10): Promise<RecommendationResponse> {\n    const response = await fetch(`${this.baseUrl}/popular?top_k=${topK}`);\n    if (!response.ok) {\n      throw new Error('Failed to get popular recipes');\n    }\n    return response.json();\n  }\n\n  /**\n   * 레시피 상세\n   */\n  async getRecipeDetail(recipeId: number): Promise<any> {\n    const response = await fetch(`${this.baseUrl}/recipe/${recipeId}`);\n    if (!response.ok) {\n      throw new Error(`Recipe ${recipeId} not found`);\n    }\n    return response.json();\n  }\n}\n\n// 싱글톤 인스턴스\nexport const recipeApi = new RecipeApiClient();\nEOF\n```",
      "verificationCriteria": "frontend/src/recipeApi.ts 파일이 생성되어야 합니다."
    },
    {
      "id": "bc970256-3f62-47fd-ae9f-ffad4925990c",
      "name": "Phase 8.2: React 컴포넌트 작성",
      "description": "추천 레시피를 표시하고 상호작용하는 React 컴포넌트를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:20:56.813Z",
      "updatedAt": "2025-10-30T04:20:56.813Z",
      "implementationGuide": "```bash\ncat > frontend/src/RecipeRecommendation.tsx << 'EOF'\n/**\n * Recipe Recommendation Component\n */\nimport React, { useState, useEffect } from 'react';\nimport { recipeApi, Recipe } from './recipeApi';\n\ninterface RecipeRecommendationProps {\n  userId: number;\n  topK?: number;\n}\n\nexport const RecipeRecommendation: React.FC<RecipeRecommendationProps> = ({\n  userId,\n  topK = 10,\n}) => {\n  const [recommendations, setRecommendations] = useState<Recipe[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    fetchRecommendations();\n  }, [userId, topK]);\n\n  const fetchRecommendations = async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await recipeApi.getRecommendations({\n        user_id: userId,\n        top_k: topK,\n        exclude_rated: true,\n      });\n      setRecommendations(response.recommendations);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className=\"flex justify-center items-center p-8\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500\"></div>\n        <span className=\"ml-4 text-gray-600\">추천 레시피를 불러오는 중...</span>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n        <p className=\"text-red-800\">❌ {error}</p>\n        <button\n          onClick={fetchRecommendations}\n          className=\"mt-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n        >\n          다시 시도\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"recipe-recommendations\">\n      <h2 className=\"text-2xl font-bold mb-6\">\n        🍳 당신을 위한 추천 레시피\n      </h2>\n\n      {recommendations.length === 0 ? (\n        <p className=\"text-gray-500\">추천할 레시피가 없습니다.</p>\n      ) : (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {recommendations.map((recipe, index) => (\n            <RecipeCard key={recipe.recipe_id} recipe={recipe} rank={index + 1} />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n\ninterface RecipeCardProps {\n  recipe: Recipe;\n  rank: number;\n}\n\nconst RecipeCard: React.FC<RecipeCardProps> = ({ recipe, rank }) => {\n  const [showDetails, setShowDetails] = useState(false);\n\n  return (\n    <div className=\"bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow p-6\">\n      {/* Rank Badge */}\n      <div className=\"flex items-start justify-between mb-3\">\n        <span className=\"inline-flex items-center justify-center w-8 h-8 rounded-full bg-blue-500 text-white font-bold text-sm\">\n          {rank}\n        </span>\n        <span className=\"text-sm text-gray-500\">\n          매칭도: {(recipe.score * 100).toFixed(1)}%\n        </span>\n      </div>\n\n      {/* Recipe Name */}\n      <h3 className=\"text-lg font-semibold mb-2 text-gray-800\">\n        {recipe.recipe_name}\n      </h3>\n\n      {/* Info */}\n      <div className=\"space-y-2 text-sm text-gray-600\">\n        {recipe.cooking_time && (\n          <div className=\"flex items-center\">\n            <span className=\"mr-2\">⏱️</span>\n            <span>{recipe.cooking_time}분</span>\n          </div>\n        )}\n\n        {recipe.n_ingredients && (\n          <div className=\"flex items-center\">\n            <span className=\"mr-2\">🥕</span>\n            <span>재료 {recipe.n_ingredients}개</span>\n          </div>\n        )}\n\n        {recipe.avg_rating && (\n          <div className=\"flex items-center\">\n            <span className=\"mr-2\">⭐</span>\n            <span>{recipe.avg_rating.toFixed(1)}/5.0</span>\n          </div>\n        )}\n      </div>\n\n      {/* Ingredients Toggle */}\n      {recipe.ingredients && (\n        <div className=\"mt-4\">\n          <button\n            onClick={() => setShowDetails(!showDetails)}\n            className=\"text-blue-600 hover:text-blue-800 text-sm font-medium\"\n          >\n            {showDetails ? '재료 숨기기 ▲' : '재료 보기 ▼'}\n          </button>\n\n          {showDetails && (\n            <div className=\"mt-2 p-3 bg-gray-50 rounded\">\n              <ul className=\"text-sm text-gray-700 space-y-1\">\n                {recipe.ingredients.slice(0, 5).map((ing, i) => (\n                  <li key={i}>• {ing}</li>\n                ))}\n                {recipe.ingredients.length > 5 && (\n                  <li className=\"text-gray-500\">\n                    ... 외 {recipe.ingredients.length - 5}개\n                  </li>\n                )}\n              </ul>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Action Button */}\n      <button className=\"mt-4 w-full py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors\">\n        레시피 보기\n      </button>\n    </div>\n  );\n};\n\nexport default RecipeRecommendation;\nEOF\n```",
      "verificationCriteria": "frontend/src/RecipeRecommendation.tsx 파일이 생성되어야 합니다."
    },
    {
      "id": "f0b87001-06de-408a-be5e-5e13eebef699",
      "name": "Phase 8.3: Next.js 페이지 예제 작성",
      "description": "React 컴포넌트를 활용하여 추천 레시피를 표시하는 Next.js 페이지 예제를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:21:35.451Z",
      "updatedAt": "2025-10-30T04:21:35.451Z",
      "implementationGuide": "```bash\ncat > frontend/pages/recommendations.tsx << 'EOF'\n/**\n * Recommendations Page (Next.js)\n */\nimport { useState } from 'react';\nimport RecipeRecommendation from '../src/RecipeRecommendation';\n\nexport default function RecommendationsPage() {\n  const [userId, setUserId] = useState<number>(42);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 py-12 px-4 sm:px-6 lg:px-8\">\n      <div className=\"max-w-7xl mx-auto\">\n        {/* Header */}\n        <div className=\"text-center mb-12\">\n          <h1 className=\"text-4xl font-bold text-gray-900 mb-4\">\n            🍽️ AI 레시피 추천 시스템\n          </h1>\n          <p className=\"text-lg text-gray-600\">\n            Neural Collaborative Filtering으로 당신만을 위한 레시피를 찾아드립니다\n          </p>\n        </div>\n\n        {/* User ID Input */}\n        <div className=\"bg-white rounded-lg shadow p-6 mb-8\">\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n            사용자 ID 입력\n          </label>\n          <div className=\"flex gap-4\">\n            <input\n              type=\"number\"\n              value={userId}\n              onChange={(e) => setUserId(Number(e.target.value))}\n              className=\"flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500\"\n              placeholder=\"사용자 ID\"\n            />\n            <button\n              onClick={() => window.location.reload()}\n              className=\"px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700\"\n            >\n              새로고침\n            </button>\n          </div>\n        </div>\n\n        {/* Recommendations */}\n        <RecipeRecommendation userId={userId} topK={12} />\n\n        {/* Footer */}\n        <div className=\"mt-12 text-center text-sm text-gray-500\">\n          <p>Powered by PyTorch & FastAPI</p>\n          <p className=\"mt-1\">\n            Model: Neural Collaborative Filtering (NCF)\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\nEOF\n```",
      "verificationCriteria": "frontend/pages/recommendations.tsx 파일이 생성되어야 합니다."
    },
    {
      "id": "26818dfc-562e-493b-bd83-4e981dad684a",
      "name": "Phase 8.4: Git 커밋",
      "description": "TypeScript 프론트엔드 연동에 대한 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:21:53.065Z",
      "updatedAt": "2025-10-30T04:21:53.065Z",
      "implementationGuide": "```bash\ngit add frontend/\ngit commit -m \"feat: Add TypeScript frontend integration\n\n- Created API client (recipeApi.ts)\n- Created React component (RecipeRecommendation)\n- Created Next.js page example\n- Added responsive UI with Tailwind CSS\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "58e23aa5-ec5f-4bb9-b1aa-9b5cf54726fc",
      "name": "Phase 9.1: Dockerfile 작성",
      "description": "FastAPI 애플리케이션을 Docker 컨테이너로 빌드하기 위한 Dockerfile을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:22:16.453Z",
      "updatedAt": "2025-10-30T04:22:16.453Z",
      "implementationGuide": "```bash\ncat > Dockerfile << 'EOF'\nFROM python:3.10-slim\n\nWORKDIR /app\n\n# 시스템 패키지 설치\nRUN apt-get update && apt-get install -y \\\n    build-essential \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Python 패키지 설치\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 애플리케이션 코드 복사\nCOPY models/ ./models/\nCOPY api/ ./api/\nCOPY training/ ./training/\nCOPY configs/ ./configs/\nCOPY data/meta.json ./data/meta.json\nCOPY data/RAW_recipes.csv ./data/RAW_recipes.csv\nCOPY data/RAW_interactions.csv ./data/RAW_interactions.csv\nCOPY checkpoints/best_model.pth ./checkpoints/best_model.pth\n\n# 포트 노출\nEXPOSE 8000\n\n# 서버 실행\nCMD [\"uvicorn\", \"api.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\nEOF\n```",
      "verificationCriteria": "Dockerfile이 생성되어야 합니다."
    },
    {
      "id": "58d19bd0-61c1-4a2d-b1a4-416df5fc099e",
      "name": "Phase 9.2: docker-compose.yml 작성",
      "description": "Docker 컨테이너를 관리하고 실행하기 위한 `docker-compose.yml` 파일을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:22:38.436Z",
      "updatedAt": "2025-10-30T04:22:38.436Z",
      "implementationGuide": "```bash\ncat > docker-compose.yml << 'EOF'\nversion: '3.8'\n\nservices:\n  api:\n    build: .\n    container_name: recipe-recommendation-api\n    ports:\n      - \"8000:8000\"\n    volumes:\n      - ./checkpoints:/app/checkpoints\n      - ./data:/app/data\n    environment:\n      - PYTHONUNBUFFERED=1\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  # (선택) Redis 캐싱\n  redis:\n    image: redis:7-alpine\n    container_name: recipe-recommendation-redis\n    ports:\n      - \"6379:6379\"\n    restart: unless-stopped\n\nnetworks:\n  default:\n    name: recipe-recommendation-network\nEOF\n```",
      "verificationCriteria": "docker-compose.yml 파일이 생성되어야 합니다."
    },
    {
      "id": "3231496e-50f4-4147-b2a2-1ccf39180a2e",
      "name": "Phase 9.3: .dockerignore 작성",
      "description": "Docker 이미지 빌드 시 불필요한 파일이나 폴더를 제외하기 위한 `.dockerignore` 파일을 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:22:49.066Z",
      "updatedAt": "2025-10-30T04:22:49.066Z",
      "implementationGuide": "```bash\ncat > .dockerignore << 'EOF'\n.git\n.gitignore\n__pycache__\n*.pyc\n*.pyo\n*.pyd\nvenv/\n.venv/\nnotebooks/\ntests/\n.ipynb_checkpoints/\n*.ipynb\n.DS_Store\n.vscode/\n.idea/\n*.md\ndata/*.csv\n!data/RAW_recipes.csv\n!data/RAW_interactions.csv\n!data/meta.json\nEOF\n```",
      "verificationCriteria": ".dockerignore 파일이 생성되어야 합니다."
    },
    {
      "id": "49cb7d68-8aa9-4c81-bbdc-90fb6ec8aa2e",
      "name": "Phase 9.4: Docker 빌드 및 실행 테스트",
      "description": "작성된 Dockerfile과 docker-compose.yml을 사용하여 이미지를 빌드하고 컨테이너를 실행하여 테스트합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:23:00.747Z",
      "updatedAt": "2025-10-30T04:23:00.747Z",
      "implementationGuide": "```bash\n# 이미지 빌드\ndocker-compose build\n\n# 컨테이너 실행\ndocker-compose up -d\n\n# 로그 확인\ndocker-compose logs -f api\n\n# Health check\ncurl http://localhost:8000/health\n\n# 추천 테스트\ncurl -X POST http://localhost:8000/recommend \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"user_id\": 42, \"top_k\": 3}'\n\n# 컨테이너 중지\ndocker-compose down\n```",
      "verificationCriteria": "Docker 컨테이너가 정상적으로 실행되고 API 응답을 확인할 수 있어야 합니다."
    },
    {
      "id": "0b60117c-dbdb-4b73-aa6b-7670276cdc4e",
      "name": "Phase 9.5: Git 커밋",
      "description": "Docker 컨테이너화 관련 변경사항을 커밋합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:23:09.677Z",
      "updatedAt": "2025-10-30T04:23:09.677Z",
      "implementationGuide": "```bash\ngit add Dockerfile docker-compose.yml .dockerignore\ngit commit -m \"feat: Add Docker containerization\n\n- Created Dockerfile for API server\n- Created docker-compose.yml\n- Added .dockerignore\n- Tested container build and run\"\n```",
      "verificationCriteria": "Git 커밋이 완료되어야 합니다."
    },
    {
      "id": "ba55a3f4-9243-4905-a94b-f74958694902",
      "name": "Phase 10.1: API 문서 작성",
      "description": "API 엔드포인트, 요청/응답 형식, 에러 처리 등을 포함하는 API 문서를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:23:32.933Z",
      "updatedAt": "2025-10-30T04:23:32.933Z",
      "implementationGuide": "```bash\ncat > docs/API.md << 'EOF'\n# Recipe Recommendation API Documentation\n\n## Base URL\n```\nhttp://localhost:8000\n```\n\n## Endpoints\n\n### 1. Health Check\n**GET** `/health`\n\n서버 상태 확인\n\n**Response**:\n```\n{\n  \"status\": \"healthy\",\n  \"model_loaded\": true,\n  \"num_users\": 226571,\n  \"num_recipes\": 231638,\n  \"device\": \"mps\"\n}\n```\n\n---\n\n### 2. Get Recommendations\n**POST** `/recommend`\n\n사용자에게 레시피 추천\n\n**Request**:\n```\n{\n  \"user_id\": 42,\n  \"top_k\": 10,\n  \"exclude_rated\": true\n}\n```\n\n**Response**:\n```\n{\n  \"user_id\": 42,\n  \"recommendations\": [\n    {\n      \"recipe_id\": 123,\n      \"recipe_name\": \"Chocolate Chip Cookies\",\n      \"score\": 0.9543,\n      \"ingredients\": [\"flour\", \"sugar\", \"butter\"],\n      \"cooking_time\": 30,\n      \"n_ingredients\": 8\n    }\n  ],\n  \"total_count\": 10\n}\n```\n\n---\n\n### 3. Get Popular Recipes\n**GET** `/popular?top_k=10`\n\n인기 레시피 조회\n\n**Response**:\n```\n{\n  \"user_id\": -1,\n  \"recommendations\": [...],\n  \"total_count\": 10\n}\n```\n\n---\n\n### 4. Get Recipe Detail\n**GET** `/recipe/{recipe_id}`\n\n레시피 상세 정보\n\n**Response**:\n```\n{\n  \"recipe_id\": 137739,\n  \"name\": \"Chocolate Chip Cookies\",\n  \"minutes\": 30,\n  \"n_steps\": 9,\n  \"n_ingredients\": 8,\n  \"description\": \"Classic chocolate chip cookies...\"\n}\n```\n\n---\n\n## Error Responses\n\n### 400 Bad Request\n```\n{\n  \"error\": \"Invalid request\",\n  \"detail\": \"Invalid user_id\"\n}\n```\n\n### 404 Not Found\n```\n{\n  \"error\": \"Not found\",\n  \"detail\": \"Recipe not found\"\n}\n```\n\n### 500 Internal Server Error\n```\n{\n  \"error\": \"Internal server error\",\n  \"detail\": \"Error message\"\n}\n```\n\n---\n\n## Rate Limiting\n- 현재 제한 없음\n- 프로덕션 환경에서는 1000 requests/hour 권장\n\n## Authentication\n- 현재 인증 없음\n- 프로덕션 환경에서는 API Key 또는 JWT 권장\nEOF\n```",
      "verificationCriteria": "docs/API.md 파일이 생성되어야 합니다."
    },
    {
      "id": "e2280009-2f28-4329-9d5d-9bee1b8f4792",
      "name": "Phase 10.2: 배포 가이드 작성",
      "description": "로컬, Docker, AWS EC2 환경에서의 배포 방법을 설명하는 가이드를 작성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:24:51.713Z",
      "updatedAt": "2025-10-30T04:24:51.713Z",
      "implementationGuide": "```bash\ncat > docs/DEPLOYMENT.md << 'EOF'\n# Deployment Guide\n\n## Local Development\n\n### 1. 환경 설정\n```\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n```\n\n### 2. 모델 학습\n```\npython training/preprocess.py\npython training/train.py\n```\n\n### 3. API 서버 실행\n```\nuvicorn api.main:app --reload\n```\n\n---\n\n## Docker Deployment\n\n### 1. 이미지 빌드\n```\ndocker-compose build\n```\n\n### 2. 컨테이너 실행\n```\ndocker-compose up -d\n```\n\n### 3. 로그 확인\n```\ndocker-compose logs -f\n```\n\n### 4. 중지\n```\ndocker-compose down\n```\n\n---\n\n## AWS EC2 Deployment\n\n### 1. EC2 인스턴스 생성\n- Instance Type: t3.medium 이상\n- OS: Ubuntu 22.04 LTS\n- Storage: 20GB 이상\n\n### 2. SSH 접속\n```\nssh -i your-key.pem ubuntu @your-ec2-ip\n```\n\n### 3. Docker 설치\n```\nsudo apt update\nsudo apt install -y docker.io docker-compose\nsudo usermod -aG docker ubuntu\n```\n\n### 4. 코드 배포\n```\ngit clone https://github.com/your-repo/pytorch-recipe-recommendation.git\ncd pytorch-recipe-recommendation\n```\n\n### 5. 실행\n```\ndocker-compose up -d\n```\n\n### 6. Nginx 설정 (선택)\n```\nsudo apt install nginx\n\n# /etc/nginx/sites-available/recipe-api\nserver {\n    listen 80;\n    server_name your-domain.com;\n\n    location / {\n        proxy_pass http://localhost:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n```\n\n---\n\n## Monitoring\n\n### Health Check\n```\ncurl http://your-server/health\n```\n\n### Logs\n```\ndocker-compose logs -f api\n```\n\n### Metrics\n- CPU/Memory 사용률\n- API 응답 시간\n- 에러율\n\n---\n\n## Scaling\n\n### Horizontal Scaling\n- Load Balancer (AWS ALB, Nginx)\n- 여러 API 인스턴스 실행\n- Redis 캐싱\n\n### Vertical Scaling\n- 더 큰 인스턴스 (CPU/RAM)\n- GPU 인스턴스 (추론 속도 향상)\n\n---\n\n## Backup\n\n### 모델 파일\n```\n# 정기적으로 S3에 백업\naws s3 cp checkpoints/best_model.pth s3://your-bucket/models/\n```\n\n### 데이터\n```\n# 데이터베이스 스냅샷\n# Redis RDB 백업\n```\nEOF\n```",
      "verificationCriteria": "docs/DEPLOYMENT.md 파일이 생성되어야 합니다."
    },
    {
      "id": "b79b7be9-c1c7-494d-9dd7-73280a130f0c",
      "name": "Phase 10.3: README 최종 업데이트",
      "description": "프로젝트의 모든 정보를 포함하도록 README.md 파일을 최종 업데이트합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:25:38.168Z",
      "updatedAt": "2025-10-30T04:25:38.168Z",
      "implementationGuide": "```bash\ncat > README.md << 'EOF'\n# 🍳 PyTorch Recipe Recommendation System\n\nNeural Collaborative Filtering (NCF) 기반 AI 레시피 추천 시스템\n\n[![Python](https://img.shields.io/badge/Python-3.10-blue)](https://www.python.org/)\n[![PyTorch](https://img.shields.io/badge/PyTorch-2.1.0-red)](https://pytorch.org/)\n[![FastAPI](https://img.shields.io/badge/FastAPI-0.104-green)](https://fastapi.tiangolo.com/)\n[![License](https://img.shields.io/badge/License-MIT-yellow)](LICENSE)\n\n## 📌 프로젝트 개요\n\nFood.com의 50만+ 레시피와 70만+ 사용자 리뷰 데이터를 활용하여  \n**개인화된 레시피 추천**을 제공하는 딥러닝 시스템입니다.\n\n### 주요 기능\n- ✅ **NCF 모델**: GMF + MLP 융합 구조\n- ✅ **고성능**: Test AUC 0.85+ 달성\n- ✅ **REST API**: FastAPI 기반 서빙\n- ✅ **TypeScript 연동**: React/Next.js 지원\n- ✅ **Docker 지원**: 간편한 배포\n\n---\n\n## 🏆 성능\n\n| Metric | Score |\n|--------|-------|\n| Test AUC | 0.849 |\n| Test AP | 0.951 |\n| API 응답 시간 | < 200ms |\n| 파라미터 수 | 14.5M |\n\n---\n\n## 🚀 빠른 시작\n\n### 1. 환경 설정\n```\ngit clone https://github.com/your-repo/pytorch-recipe-recommendation.git\ncd pytorch-recipe-recommendation\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n```\n\n### 2. 데이터 다운로드\n```\nkaggle datasets download -d shuyangli94/food-com-recipes-and-user-interactions -p ./data\ncd data && unzip food-com-recipes-and-user-interactions.zip\n```\n\n### 3. 모델 학습\n```\npython training/preprocess.py\npython training/train.py\n```\n\n### 4. API 서버 실행\n```\nuvicorn api.main:app --reload\n```\n\n### 5. 추천 받기\n```\ncurl -X POST http://localhost:8000/recommend \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"user_id\": 42, \"top_k\": 5}'\n```\n\n---\n\n## 🐳 Docker로 실행\n\n```\ndocker-compose up -d\ncurl http://localhost:8000/health\n```\n\n---\n\n## 📁 프로젝트 구조\n\n```\npytorch-recipe-recommendation/\n├── models/              # NCF 모델 코드\n├── training/            # 학습 스크립트\n├── api/                # FastAPI 서버\n├── frontend/           # TypeScript/React\n├── data/               # 데이터셋\n├── checkpoints/        # 학습된 모델\n├── notebooks/          # Jupyter 노트북\n├── tests/              # 테스트 코드\n├── docs/               # 문서\n└── configs/            # 설정 파일\n```\n\n---\n\n## 📊 아키텍처\n\n```\nUser Request\n    ↓\nFastAPI Server\n    ↓\nNCF Model (PyTorch)\n    ├─ GMF (Generalized Matrix Factorization)\n    └─ MLP (Multi-Layer Perceptron)\n    ↓\nTop-K Recommendations\n    ↓\nTypeScript Frontend\n```\n\n---\n\n## 📚 문서\n\n- [API 문서](docs/API.md)\n- [배포 가이드](docs/DEPLOYMENT.md)\n- [모델 아키텍처](docs/ARCHITECTURE.md)\n\n---\n\n## 🧪 테스트\n\n```\n# API 테스트\npython tests/test_api.py\n\n# 모델 테스트\npython models/ncf_model.py\npython models/dataset.py\n```\n\n---\n\n## 🛠️ 기술 스택\n\n**Backend**\n- PyTorch 2.1.0\n- FastAPI 0.104.0\n- Pandas, NumPy, scikit-learn\n\n**Frontend**\n- TypeScript\n- React/Next.js\n- Tailwind CSS\n\n**Deployment**\n- Docker & docker-compose\n- Uvicorn (ASGI server)\n- Nginx (optional)\n\n---\n\n## 📈 로드맵\n\n- [x] Phase 1: 프로젝트 설정\n- [x] Phase 2: 데이터 수집 및 EDA\n- [x] Phase 3: NCF 모델 구현\n- [x] Phase 4: 데이터 전처리\n- [x] Phase 5: 모델 학습\n- [x] Phase 6: 추론 로직\n- [x] Phase 7: FastAPI 서버\n- [x] Phase 8: TypeScript 연동\n- [x] Phase 9: Docker 배포\n- [x] Phase 10: 문서화\n- [ ] Phase 11: 프로덕션 배포 (AWS/GCP)\n- [ ] Phase 12: 모니터링 & 로깅\n- [ ] Phase 13: A/B 테스트\n\n---\n\n## 📝 참고 자료\n\n- [NCF 논문](https://arxiv.org/abs/1708.05031)\n- [PyTorch 공식 문서](https://pytorch.org/docs/)\n- [Food.com Dataset](https://www.kaggle.com/datasets/shuyangli94/food-com-recipes-and-user-interactions)\n\n---\n\n## 👤 작성자\n\n- 개발 기간: 2025-10-30 ~ 2025-11-05\n- GitHub: [Your GitHub]\n- Email: your @email.com\n\n---\n\n## 📄 라이센스\n\nMIT License\nEOF\n```",
      "verificationCriteria": "README.md 파일이 최종 업데이트되어야 합니다."
    },
    {
      "id": "ca1e0c54-388d-496a-a073-d913c8f82b51",
      "name": "Phase 10.4: 최종 Git 커밋 및 태그",
      "description": "문서화 및 프로젝트 마무리 작업에 대한 최종 Git 커밋을 수행하고, 프로젝트 완료 태그를 생성합니다.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-10-30T04:25:47.872Z",
      "updatedAt": "2025-10-30T04:25:47.872Z",
      "implementationGuide": "```bash\nmkdir -p docs\ngit add docs/ README.md\ngit commit -m \"docs: Complete documentation\n\n- Added API documentation\n- Added deployment guide\n- Updated README with full project info\n- Added architecture diagram\n- Added testing guide\"\n\n# 프로젝트 완료 태그\ngit tag -a v1.0.0 -m \"Release v1.0.0: Complete PyTorch Recipe Recommendation System\n\nFeatures:\n- NCF model with Test AUC 0.849\n- FastAPI REST API\n- TypeScript frontend integration\n- Docker containerization\n- Comprehensive documentation\"\n\ngit log --oneline --graph\ngit tag -l\n```",
      "verificationCriteria": "Git 커밋 및 `v1.0.0` 태그가 생성되어야 합니다."
    }
  ]
}